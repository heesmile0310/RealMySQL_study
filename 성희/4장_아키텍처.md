# 4장 아키텍처

## 4.1 MySQL 엔진 아키텍처

**4.1.1.1 MySQL 엔진**

- 접속 및 쿼리 요청을 처리하는 커넥션 핸들러, SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다.
- MySQL은 표준 SQL 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환이 가능하다.

**4.1.1.2 스토리지 엔진**

- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 전담한다.
- 스토리지 엔진은 성능 향상을 위해 키 캐시나 InnoDB 버퍼 풀과 같은 기능을 내장한다.
    
**4.1.1.3 핸들러 API**

- 핸들러 요청이란? : MySQL 엔징의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데 이러한 요청을 핸들러 요청이라한다.
- 위에서 사용되는 API를 핸들러 API라고 한다.
    
### 4.1.2 MySQL 스레딩 구조

- MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며,
- 포그라운드 백그라운드 스레드로 구분된다.

**4.1.2.1 포그라운드 스레드(클라이언트 스레드)**

- MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 각 클라이언트가 요청하는 쿼리 문장을 처리한다.
- 사용자가 작업을 마치고 커넥션을 종료하면 스레드 캐시로 되돌아간다.
- 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 처리한다.
- InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드(다음 설명 참고)가 처리한다.

**4.1.2.2 백그라운드 스레드**

- InnoDB가 처리하는 백그라운드 작업
    - 인서트 버퍼를 병합하는 스레드
    - 로그를 디스크로 기록하는 스레드
    - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
    - 데이터를 버퍼로 읽어 오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드
- 5.5버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있게 되었다
- InnoDB에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 필요 없지만 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 내장 디스크 사용시 2~4, DAS나 SAN의 경우 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.
- 사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다.
- 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있고 InnoDB 또한 같다.

### 4.1.3 메모리 할당 및 사용 구조

- MySQL 메모리공간은 글로벌 메모리 영역과 로컬 메모리 영역으로 구분된다.
- 글로벌 메모리 영역과 로컬 메모리 영역은 MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.
- 
**4.1.3.1 글로벌 메모리 영역**

- 일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다.
- 모든 스레드에 의해 공유된다.
- 대표적인 글로벌 메모리 영역
    - 테이블 캐시
    - InooDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InooDB 리두 로그 버퍼
    

**4.1.3.2 로컬 메모리 영역**

- 세션 메모리 영역이라고도 표현하며, 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.
- 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역이라고도 한다.
- 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 세션 메모리 영역이라고도 표현한다.
- 로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다.
- 로컬 메모리 공간의 중요한 특징은 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수 있다는 점이다.(ex. 소트 버퍼 or 조인 버퍼)
- 대표적인 로컬 메모리 영역
    - 정렬 버퍼(Sort buffer)
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

### 4.1.4 플러그인 스토리지 엔진 모델

- 플러그인해서 사용할 수 있는 것이 스토리지 엔진뿐만 아니라 검색어 파서도 플러그인 형태로 개발할 수 있으며, 사용자 인증을 위한 작업도 플러그인으로 구현되어 제공된다.
- MySQL은 이미 많은 스토리지 엔진을 가지고 있다.
- 많은 이용자의 요구조건을 만족시키기 위해 사용자가 직접 개발해서 사용할 수도 있다.
    
- MySQL 엔진이 스토리지 엔진ㄴ을 조정하기 위해 핸들러라는 것을 사용하게 된다.
- ‘Handler_’ 로 시작하는 상태변수 = MySQL엔진이 각 스토리지 엔진에게 보낸 멸령의 횟수를 의미하는 변수로 이해하자
- 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데. 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.

### 4.1.5 컴포넌트

- MySQL 8.0 부터 플러그인 아키텍처를 대체하기 위해 지원하며 플러그인의 단점들을 보완한다.
    1. 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음.
    2. 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
    3. 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
    

### 4.1.6 쿼리 실행 구조

![Untitled 6](https://user-images.githubusercontent.com/76901060/206917654-b18a3396-980e-4b77-90cb-a1e97959b33a.png)

**4.1.6.1 쿼리 파서**

- 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리형태의 구조로 만들어 내는 작업을 의미한다.
- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견하여 전달한다.

**4.1.6.2 전처리기**

- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.

**4.1.6.3 옵티마이저 ★★★(매우중요)**

- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당
- DBMS의 두뇌에 해당한다.

**4.1.6.4 실행엔진**

- 실행 엔진은 손에 해당한다.
- 회사로 비유하면 옵티마이저는 회사의 경영진, 실행엔진은 중간관리자, 핸들러는 각 업무의 실무자로 볼 수 있다.

**4.1.6.5 핸들러(스토리지 엔진)**

- MySQL 서버의 가장 밑단에서 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당한다.
- MyISAM 테이블을 조작하는경우 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우 핸들러가 InnoDB 스토리지 엔진이 된다.

### 4.1.7 복제

- MySQL 서버의 복제에 관해서는 매우 중요한 역할이기에 별도의 장에서 다루기로 한다.(16장)

### 4.1.8 쿼리 캐시

- MySQL 서버가 발전하면서 성능이 개선된는 과정에서 쿼리 캐시는 계속된 동시 처리 성능 저하와 많은 버그의 원인이 되어 MySQL 8.0으로 올라오면서 쿼리 캐시는 MySQL 서버의 기능에서 완전히 제거 되었다.

### 4.1.9 스레드 풀

- 스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적이다.
- 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성하는데, 스레드 그룹의 개수는 thread_pool_size 시스템 변수를 변경해서 조정할 수 있다.
